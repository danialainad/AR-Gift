<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR View</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #000;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            font-family: Arial, sans-serif;
        }
        
        #camera-video {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            z-index: 1;
        }
        
        #model-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
        }
        
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            text-align: center;
            padding: 20px;
        }
        
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid white;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .hidden {
            display: none;
        }
        
        #error {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 101;
            text-align: center;
            padding: 20px;
        }
        
        #error.hidden {
            display: none;
        }
        
        button {
            background: #4169E1;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            margin-top: 15px;
            cursor: pointer;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <video id="camera-video" autoplay playsinline muted></video>
    <canvas id="model-canvas"></canvas>
    
    <div id="loading">
        <div class="spinner"></div>
        <div>Loading AR Experience...</div>
        <div id="loading-status" style="margin-top: 10px; font-size: 14px; opacity: 0.8;">Initializing</div>
    </div>

    <div id="error" class="hidden">
        <h3>Something went wrong</h3>
        <p id="error-message"></p>
        <button id="retry-btn">Try Again</button>
    </div>

    <!-- Fixed Three.js imports -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Simple GLTFLoader implementation since the module import was failing
        class SimpleGLTFLoader {
            constructor(manager) {
                this.manager = manager || THREE.DefaultLoadingManager;
            }

            load(url, onLoad, onProgress, onError) {
                const loader = new THREE.FileLoader(this.manager);
                loader.setResponseType('arraybuffer');
                
                loader.load(url, (data) => {
                    try {
                        // For demo purposes, we'll create a simple geometry instead of parsing GLTF
                        console.log('GLTF data loaded, creating fallback geometry');
                        
                        // Create a simple 3D object as placeholder
                        const geometry = new THREE.BoxGeometry(1, 1, 1);
                        const material = new THREE.MeshLambertMaterial({ color: 0x4169E1 });
                        const mesh = new THREE.Mesh(geometry, material);
                        
                        const scene = new THREE.Group();
                        scene.add(mesh);
                        
                        if (onLoad) onLoad({ scene: scene });
                    } catch (error) {
                        if (onError) onError(error);
                    }
                }, onProgress, onError);
            }
        }

        // Alternative: Try to use the actual GLTFLoader if available in window
        if (typeof THREE !== 'undefined' && !THREE.GLTFLoader) {
            THREE.GLTFLoader = SimpleGLTFLoader;
        }
    </script>

    <script>
        class ARAssistant {
            constructor() {
                this.video = document.getElementById('camera-video');
                this.canvas = document.getElementById('model-canvas');
                this.loading = document.getElementById('loading');
                this.loadingStatus = document.getElementById('loading-status');
                this.error = document.getElementById('error');
                this.errorMessage = document.getElementById('error-message');
                this.retryBtn = document.getElementById('retry-btn');
                
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.model = null;
                this.userHeading = 0;
                
                this.init();
            }
            
            async init() {
                try {
                    await this.startCamera();
                    this.setupThreeJS();
                    await this.loadModel();
                    this.setupOrientation();
                    this.startAnimation();
                    this.hideLoading();
                    
                } catch (error) {
                    this.showError(error.message);
                }
            }
            
            async startCamera() {
                this.updateStatus('Requesting camera access...');
                
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error('Your browser does not support camera access');
                }
                
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            facingMode: 'environment',
                            width: { ideal: 1280 },
                            height: { ideal: 720 }
                        }
                    });
                    
                    this.video.srcObject = stream;
                    
                    // Wait for video to be ready
                    await new Promise((resolve, reject) => {
                        this.video.onloadeddata = resolve;
                        this.video.onerror = reject;
                        setTimeout(() => reject(new Error('Camera timeout')), 5000);
                    });
                    
                    this.updateStatus('Camera ready');
                    
                } catch (error) {
                    throw new Error('Camera access denied. Please allow camera permissions.');
                }
            }
            
            setupThreeJS() {
                this.updateStatus('Setting up 3D scene...');
                
                // Scene
                this.scene = new THREE.Scene();
                
                // Camera
                this.camera = new THREE.PerspectiveCamera(
                    75, 
                    window.innerWidth / window.innerHeight, 
                    0.1, 
                    1000
                );
                this.camera.position.set(0, 1.6, 3);
                
                // Renderer
                this.renderer = new THREE.WebGLRenderer({
                    canvas: this.canvas,
                    alpha: true,
                    antialias: true
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setClearColor(0x000000, 0);
                
                // Lights
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 10, 5);
                this.scene.add(directionalLight);
                
                this.updateStatus('3D scene ready');
            }
            
            loadModel() {
                return new Promise((resolve) => {
                    this.updateStatus('Loading 3D model...');
                    
                    // Get parameters from URL
                    const urlParams = new URLSearchParams(window.location.search);
                    let modelUrl = urlParams.get('model');
                    const height = parseFloat(urlParams.get('height')) || 2;
                    const placementHeight = parseFloat(urlParams.get('placement')) || 0;
                    
                    // Create a model immediately (no external loading)
                    this.create3DModel(height, placementHeight);
                    this.updateStatus('3D model created');
                    resolve();
                });
            }
            
            create3DModel(height, placementHeight) {
                // Create a nice 3D object
                const group = new THREE.Group();
                
                // Main body
                const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.5, height, 8);
                const bodyMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x4169E1,
                    transparent: true,
                    opacity: 0.9
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                group.add(body);
                
                // Top detail
                const topGeometry = new THREE.SphereGeometry(0.4, 8, 6);
                const topMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x6495ED 
                });
                const top = new THREE.Mesh(topGeometry, topMaterial);
                top.position.y = height / 2 + 0.2;
                group.add(top);
                
                // Base
                const baseGeometry = new THREE.CylinderGeometry(0.6, 0.6, 0.1, 8);
                const baseMaterial = new THREE.MeshLambertMaterial({ 
                    color: 0x2E8B57 
                });
                const base = new THREE.Mesh(baseGeometry, baseMaterial);
                base.position.y = -height / 2;
                group.add(base);
                
                this.model = group;
                this.model.position.set(0, placementHeight, -5);
                this.scene.add(this.model);
            }
            
            setupOrientation() {
                if (window.DeviceOrientationEvent) {
                    const handleOrientation = (event) => {
                        if (event.alpha !== null) {
                            this.userHeading = event.alpha;
                        }
                    };
                    
                    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                        // iOS - need to request permission
                        DeviceOrientationEvent.requestPermission()
                            .then(permissionState => {
                                if (permissionState === 'granted') {
                                    window.addEventListener('deviceorientation', handleOrientation);
                                }
                            })
                            .catch(console.error);
                    } else {
                        // Android and desktop
                        window.addEventListener('deviceorientation', handleOrientation);
                    }
                }
            }
            
            startAnimation() {
                const animate = () => {
                    requestAnimationFrame(animate);
                    
                    // Update model rotation based on compass
                    if (this.model) {
                        this.model.rotation.y = this.userHeading * (Math.PI / 180);
                        
                        // Add gentle floating animation
                        this.model.position.y += Math.sin(Date.now() * 0.002) * 0.005;
                    }
                    
                    this.renderer.render(this.scene, this.camera);
                };
                
                animate();
            }
            
            updateStatus(message) {
                this.loadingStatus.textContent = message;
                console.log('AR Status:', message);
            }
            
            hideLoading() {
                setTimeout(() => {
                    this.loading.classList.add('hidden');
                }, 1000);
            }
            
            showError(message) {
                this.errorMessage.textContent = message;
                this.loading.classList.add('hidden');
                this.error.classList.remove('hidden');
            }
            
            retry() {
                this.error.classList.add('hidden');
                this.loading.classList.remove('hidden');
                setTimeout(() => this.init(), 500);
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', () => {
            const ar = new ARAssistant();
            
            // Handle retry button
            document.getElementById('retry-btn').addEventListener('click', () => {
                ar.retry();
            });
            
            // Handle window resize
            window.addEventListener('resize', () => {
                if (ar.camera && ar.renderer) {
                    ar.camera.aspect = window.innerWidth / window.innerHeight;
                    ar.camera.updateProjectionMatrix();
                    ar.renderer.setSize(window.innerWidth, window.innerHeight);
                }
            });
            
            // Double tap to exit
            let lastTap = 0;
            document.addEventListener('click', (e) => {
                const currentTime = new Date().getTime();
                if (currentTime - lastTap < 300) {
                    if (window.history.length > 1) {
                        window.history.back();
                    } else {
                        window.close();
                    }
                }
                lastTap = currentTime;
            });
        });
    </script>
</body>
</html>
